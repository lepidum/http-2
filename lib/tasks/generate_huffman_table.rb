desc "Generate Huffman precompiled tables"
task :generate_table do
  HuffmanTable::Node.generate_state_table
end

require_relative '../http/2/huffman'

module HuffmanTable
  BITS_AT_ONCE = 4
  EOS = 256

  class Node
    attr_accessor :next, :emit, :final
    attr_accessor :transitions
    attr_accessor :id
    @@id = 0
    def initialize
      @next = [nil, nil]
      @id = @@id
      @@id += 1
      @final = false
    end
    def add(code, len, chr)
      chr == EOS and self.final = true
      if len == 0
        @emit = chr
      else
        bit = (code & (1 << (len - 1))) == 0 ? 0 : 1
        node = @next[bit] ||= Node.new
        node.add(code, len - 1, chr)
      end
    end

    class Transition
      attr_accessor :emit, :node
      def initialize(emit, node)
        @emit = emit
        @node = node
      end
    end

    def self.generate_tree
      @root = new
      HTTP2::Header::Huffman::CODES.each_with_index do |c, chr|
        code, len = c
        @root.add(code, len, chr)
      end
      @root
    end

    def self.generate_machine
      generate_tree
      togo = Set[@root]
      @states = Set[@root]

      until togo.empty?
        node = togo.first
        togo.delete(node)

        next if node.transitions
        node.transitions = Array[1 << BITS_AT_ONCE]

        (1 << BITS_AT_ONCE).times do |input|
          n = node
          emit = ''
          (BITS_AT_ONCE - 1).downto(0) do |i|
            bit = (input & (1 << i)) == 0 ? 0 : 1
            n = n.next[bit]
            if n.emit
              if n.emit == EOS
                emit = EOS      # cause error on decoding
              else
                emit << n.emit.chr('binary')
              end
              n = @root
            end
          end
          node.transitions[input] = Transition.new(emit, n)
          togo << n
          @states << n
        end
      end
      puts "#{@states.size} states"
      @root
    end

    def self.generate_state_table
      generate_machine
      state_id = {}
      id_state = {}
      state_id[@root] = 0
      id_state[0] = @root
      id = 1
      (@states - [@root]).each do |s|
        state_id[s] = id
        id_state[id] = s
        id += 1
      end

      File.open(File.expand_path("../http/2/huffman_statemachine.rb", File.dirname(__FILE__)), "w") do |f|
        f.print <<HEADER
# Machine generated Huffman decoder state machine.
# DO NOT EDIT THIS FILE.

# The following task generates this file.
#   rake generate_huffman_table

module HTTP2
  module Header
    class Huffman
      MACHINE = [
HEADER
        id.times do |i|
          n = id_state[i]
          f.print "        [#{n.final},["
          (1 << BITS_AT_ONCE).times do |t|
            emit = n.transitions[t].emit
            emit == EOS or emit = emit.dup.force_encoding('binary')
            f.print %Q/[#{emit.inspect},#{state_id[n.transitions[t].node]}],/
          end
          f.print "]],\n"
        end
        f.print <<TAILER
      ]
    end
  end
end
TAILER
      end
    end

    def self.root
      @root
    end

    def self.decode(input, len)
      emit = ''
      n = root
      nibbles = input.unpack("C*").flat_map{|b| [((b & 0xf0) >> 4), b & 0xf]}
      while emit.size < len && nibbles.size > 0
        nb = nibbles.shift
        t = n.transitions[nb]
        emit << t.emit
        n = t.node
      end
      unless emit.size == len && n.final && nibbles.all?{|x| x == 0xf}
        puts "len = #{emit.size} n.final = #{n.final} nibbles = #{nibbles}"
      end
      emit
    end
  end
end
